// Задание 1. Шифр Цезаря
// Юлий Цезарь использовал свой способ шифрования текста. Каждая буква заменялась на
// следующую по алфавиту через K позиций по кругу. Если взять английский алфавит и
// K = 3, то в слове, которое мы хотим зашифровать, буква A станет буквой D, B станет
// E и так далее. Если для сдвига на данное число позиций алфавита не хватает, то он
// зацикливается, то есть последняя буква алфавита Z, сдвинутая на одну позицию, будет
// преобразовываться в A.
//
// Напишите функцию encrypt_caesar, в которую передаётся текст и сдвиг и которая
// возвращает зашифрованный текст. Считаем, что входные строки состоят лишь из
// английских букв. Если там содержатся и другие символы, то их надо выдать без
// шифрования. Регистр букв (заглавные и строчные) меняться не должен.
//
// Пример 1:
// Text: aBxZ*
// Code: 67
// Результат:
// pQmO*
//
// Пример 2:
// Text: The quick brown fox jumps over the lazy dog
// Code: 3
// Результат:
// Wkh txlfn eurzq ira mxpsv ryhu wkh odcb grj
//
// Рекомендации
// Функция шифрования принимает на вход строку и смещение. Нужно добавить смещение к
// числовому значению очередной буквы, но учесть зацикленность нашего алфавита.
//
// У английской буквы ‘A’ числовое значение 65. Вы можете узнать остальные значения при
// помощи cout << int(‘интересующая вас буква’);
//
// То есть для получения числового значения символа добавляем одинарные кавычки. Чтобы
// проверить, попадает ли символ в диапазон, нужно сделать
// if(symbol >= ‘x’ && symbol <=’z’).
//
// Коды у заглавных и строчных символов разные. Чтобы ограничить число верхним пределом,
// можно воспользоваться оператором %.
//
// При делении с остатком на число 26 никогда не получим число больше него. Значит, не
// выйдем за пределы алфавита, а снова попадём в его начало (27 % 26 даёт 1, то есть
// снова первый символ). Чтобы зашифровать символ s, нужно:
//
// 1. Отнять от него значение первого символа алфавита (‘a’ или ‘A’ — вам потребуются два
//    условия для двух разных случаев). Получим порядковый номер символа в алфавите.
// 2. Добавить смещение шифра, которое указывает пользователь.
// 3. Полученное значение разделить с остатком на 26. Получим порядковый номер символа в
//    алфавите с учётом его зацикленности. Осталось получить этот символ, зная его номер.
//    Для этого к коду первого символа алфавита (‘a’ или ‘A’) добавляем полученный
//    порядковый номер.
//
// Что оценивается
// Корректность работы программы по созданию зашифрованной версии слова или текста.

#include <iostream>
#include <string>

int coding(char str, char ch, int code)
{
    str = str - ch + code;
    if (str >= 26)
        str %= 26;
    return str + ch;
}

std::string encrypt_caesar(std::string str, int code)
{

    for (int i = 0; i < str.length(); i++)
    {
        if (code >= 26)
            code %= 26;

        if (str[i] >= 'A' && str[i] <= 'Z')
            str[i] = coding(str[i], 'A', code);

        else if (str[i] >= 'a' && str[i] <= 'z')
            str[i] = coding(str[i], 'a', code);
    }

    return str;
}

int main()
{
    int code;
    std::string str, result;

    std::cout << "Text: ";
    std::getline(std::cin, str);

    std::cout << "Code: ";
    std::cin >> code;

    std::cout << "Результат: \n" << encrypt_caesar(str, code) << "\n";
}