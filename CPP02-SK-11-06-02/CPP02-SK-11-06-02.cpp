// Задание 2. Проверка корректности email-адреса
// Напишите программу, которая проверяет корректность email-адреса, введённого
// пользователем.
// Согласно международным требованиям, корректный email-адрес должен состоять из двух
// частей, разделённых знаком @. Первая часть должна иметь длину не менее одного и не
// более 64 символов, вторая часть — не менее одного и не более 63 символов. Из
// символов допускаются только английские буквы, цифры и знак «-» (дефис), а также
// точка. Точка не может быть первым или последним символом, две точки не могут идти
// подряд. В первой части (перед символом @), кроме вышеперечисленных, разрешены ещё
// следующие символы:
// !#$%&'*+-/=?^_`{|}~

// Пользователь вводит строку, задающую email-адрес. Программа должна вывести слово
// Yes, если адрес корректен, а в противном случае — слово No.

// Примеры
// Корректные адреса:
// simple@example.com
// very.common@example.com
// disposable.style.email.with+symbol@example.com
// other.email-with-hyphen@example.com
// fully-qualified-domain@example.com
// user.name+tag+sorting@example.com (может на самом деле быть перенаправлен на
//     user.name@example.com в зависимости от почтового сервиса)
// x@example.com (однобуквенная локальная часть)
// example-indeed@strange-example.com
// admin@mailserver1
// example@s.example
// mailhost!username@example.org
// user%example.com@example.org

// Некорректные адреса:
// John..Doe@example.com (две точки не могут идти подряд)
// Abc.example.com (нет символа @)
// A@b@c@example.com (символ @ должен быть только один)
// a"b(c)d,e:f;g<h>i[j\k]l@example.com (есть недопустимые символы)
// 1234567890123456789012345678901234567890123456789012345678901234+x@example.com
//     (первая часть длиннее 64 символов)
// i_like_underscore@but_its_not_allow_in _this_part.example.com (во второй части
// есть недопустимый символ «_»)

// Рекомендации
// Активно используйте оператор индексации строки str[i], но помните, что индексы
// начинаются с нуля, а не с единицы.
// Создайте отдельные функции, которые выдают первую и вторую части адреса для их
// последующего анализа.
// Для валидации отдельных символов внутри части используйте дополнительные строки-
// словари, состоящие из всех корректных символов для соответствующей части.
// При разработке вспомогательных функций получения первой и второй части адреса
// воспользуйтесь циклом, который проверяет текущий символ.

// Если символ равен ‘@’, значит мы нашли границу между частями адреса.
// В функции нахождения первой части в этом месте надо остановиться и вернуть все
// символы, что были раньше (их можно накапливать в std::string при помощи оператора
// +=). Во второй функции все символы после ‘@’ тем же оператором добавляются к
// результату.
// Строка-словарь — это строка, которая в нашем случае содержит весь английский алфавит
// и символы. Каждый символ адреса надо сравнить с каждым символом из этого списка
// «допустимых символов» в цикле.
// В этом задании очень важно разбить код на отдельные функции, каждая из которых
// делает небольшую часть работы.

// Что оценивается
// Корректные результаты валидации адресов электронной почты. Должны устанавливаться как
// валидные адреса, так и невалидные.

#include <iostream>
#include <string>

// Точка не может быть первым или последним символом, две точки не могут идти подряд.
bool dotCheck(std::string email)
{
    bool parse = true;

    if (email[0] == '.')
    {
        std ::cout << "Ошибка! В начале не должно быть точчки.\n";
        parse = false;
    }

    if (email[email.length() - 1] == '.')
    {
        std ::cout << "Ошибка! В конце не должно быть точчки.\n";
        parse = false;
    }

    for (int i = 0; i < email.length() - 1; i++)
        if (email[i] == '.' && email[i + 1] == '.')
        {
            std ::cout << "Ошибка! Две точки не могут идти подряд.\n";
            parse = false;
            break;
        }

    return parse;
}

// Создайте отдельные функции, которые выдают первую и вторую части адреса для их
// последующего анализа.
// В функции нахождения первой части в этом месте надо остановиться и вернуть все
// символы, что были раньше (их можно накапливать в std::string при помощи оператора
// +=). Во второй функции все символы после ‘@’ тем же оператором добавляются к
// результату.

std::string partL(std::string email)
{
    // корректный email-адрес должен состоять из двух частей, разделённых знаком @.
    // Первая часть должна иметь длину не менее одного и не более 64 символов

    std::string temp = "";

    for (int i = 0; i < email.length(); i++)
    {
        int lengthL;

        if (email[i] == '@')
        {
            lengthL = i;

            if (lengthL < 1 || lengthL > 64)
            {
                std::cout << "Ошибка! Первая часть должна быть от 1 до 64 символов.\n";
                return "";
            }

            return temp;
        }
        else
            temp += email[i];
    }

    return temp;
}

std::string partR(std::string email)
{
    // корректный email-адрес должен состоять из двух частей, разделённых знаком @.
    // вторая часть — не менее одного и не более 63 символов.

    std::string temp = "";
    int lengthR = email.length();
    bool aroba = false;

    for (int i = 0; i < email.length(); i++)
    {
        if (email[i] == '@' && aroba == false)
        {
            aroba = true;
            lengthR = email.length() - i - 1;

            if (lengthR < 1 || lengthR > 63)
            {
                std::cout << "Ошибка! Вторая часть должна быть от 1 до 63 символов.\n";
                return "";
            }
        }
        else if (email[i] == '@' && aroba)
        {
            std::cout << "Ошибка! Есть два знака @ \n";
            return "";
        }
    }

    for (int i = email.length() - lengthR; i < email.length(); i++)
    {
        temp += email[i];
    }

    return temp;
}

// Из символов допускаются только английские буквы, цифры и знак «-» (дефис), а также
// точка. В первой части (перед символом @), кроме вышеперечисленных, разрешены ещё
// следующие символы:
// !#$%&'*+-/=?^_`{|}~
// Строка-словарь — это строка, которая в нашем случае содержит весь английский алфавит
// и символы. Каждый символ адреса надо сравнить с каждым символом из этого списка
// «допустимых символов» в цикле.

bool simbolCheck(std::string email, std::string checkStr)
{
    bool parse = true;
    checkStr += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890-.";

    for (int i = 0; i < email.length(); i++)
    {
        for (int j = 0; j < checkStr.length(); j++)
        {
            // Если основной символ совпал с одним из символов проверочной строки -
            // переходим к проверке следующего символа
            if (email[i] == checkStr[j])
            {
                parse = true;
                break;
            }

            // Если совпадения не было - основной цикл прервётся при проверке
            parse = false;
        }

        if (parse)
            continue;
        else
        {
            std ::cout << "Ошибка! Есть недопустимый символ.\n";
            break;
        }
    }

    return parse;
}

int main()
{
    std::string email;
    std::string sideL;
    std::string sideR;
    bool parse = true;

    std::cout << "Введите e-mail: ";
    std::cin >> email;

    sideL = partL(email);
    sideR = partR(email);

    if (sideL.length() == 0 || sideR.length() == 0)
        parse = false;

    if (parse)
        if (!dotCheck(sideL) || !dotCheck(sideR))
            parse = false;

    if (parse)
        if (!simbolCheck(sideL, "!#$%&'*+-/=?^_`{|}~") || !simbolCheck(sideR, ""))
            parse = false;

    if (parse)
        std::cout << "Yes. \n";
    else
        std::cout << "No. \n";
}